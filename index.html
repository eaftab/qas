<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Experian Address Search</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, Cantarell, sans-serif;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            min-height: 100vh;
            padding: 20px;
        }

        .container {
            max-width: 900px;
            margin: 0 auto;
            background: white;
            border-radius: 12px;
            box-shadow: 0 20px 60px rgba(0, 0, 0, 0.3);
            padding: 40px;
        }

        h1 {
            color: #333;
            margin-bottom: 30px;
            text-align: center;
            font-size: 2em;
        }

        .form-group {
            margin-bottom: 20px;
        }

        label {
            display: block;
            margin-bottom: 8px;
            color: #555;
            font-weight: 600;
            font-size: 14px;
        }

        input[type="text"],
        input[type="password"],
        input[type="number"],
        select {
            width: 100%;
            padding: 12px 16px;
            border: 2px solid #e0e0e0;
            border-radius: 8px;
            font-size: 15px;
            transition: border-color 0.3s, box-shadow 0.3s;
            background: white;
        }

        input[type="text"]:focus,
        input[type="password"]:focus,
        input[type="number"]:focus,
        select:focus {
            outline: none;
            border-color: #667eea;
            box-shadow: 0 0 0 3px rgba(102, 126, 234, 0.1);
        }

        select {
            cursor: pointer;
            appearance: none;
            background-image: url("data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' width='12' height='12' viewBox='0 0 12 12'%3E%3Cpath fill='%23667eea' d='M6 9L1 4h10z'/%3E%3C/svg%3E");
            background-repeat: no-repeat;
            background-position: right 12px center;
            padding-right: 40px;
        }

        details summary {
            list-style: none;
        }

        details summary::-webkit-details-marker {
            display: none;
        }

        details[open] summary {
            margin-bottom: 10px;
        }

        .info-text {
            font-size: 12px;
            color: #888;
            margin-top: 4px;
            font-style: italic;
        }

        .options-grid {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 15px;
        }

        @media (max-width: 768px) {
            .options-grid {
                grid-template-columns: 1fr;
            }
        }

        .full-width {
            grid-column: 1 / -1;
        }

        .checkbox-group {
            display: flex;
            align-items: center;
            gap: 10px;
            margin-bottom: 20px;
        }

        input[type="checkbox"] {
            width: 20px;
            height: 20px;
            cursor: pointer;
        }

        .checkbox-group label {
            margin: 0;
            cursor: pointer;
        }

        .autocomplete-container {
            position: relative;
        }

        .autocomplete-dropdown {
            position: absolute;
            top: 100%;
            left: 0;
            right: 0;
            background: white;
            border: 2px solid #667eea;
            border-top: none;
            border-radius: 0 0 8px 8px;
            max-height: 300px;
            overflow-y: auto;
            z-index: 1000;
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.15);
            display: none;
        }

        .autocomplete-dropdown.show {
            display: block;
        }

        .autocomplete-item {
            padding: 12px 16px;
            cursor: pointer;
            border-bottom: 1px solid #f0f0f0;
            transition: background-color 0.2s;
        }

        .autocomplete-item:last-child {
            border-bottom: none;
        }

        .autocomplete-item:hover {
            background-color: #f5f7ff;
        }

        .autocomplete-item.selected {
            background-color: #667eea;
            color: white;
        }

        .address-main {
            font-weight: 600;
            color: #333;
            margin-bottom: 4px;
        }

        .address-details {
            font-size: 13px;
            color: #666;
        }

        .autocomplete-item:hover .address-main {
            color: #667eea;
        }

        .autocomplete-item.selected .address-main,
        .autocomplete-item.selected .address-details {
            color: white;
        }

        button {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            border: none;
            padding: 14px 32px;
            border-radius: 8px;
            font-size: 16px;
            font-weight: 600;
            cursor: pointer;
            transition: transform 0.2s, box-shadow 0.2s;
            width: 100%;
        }

        button:hover:not(:disabled) {
            transform: translateY(-2px);
            box-shadow: 0 6px 20px rgba(102, 126, 234, 0.4);
        }

        button:active:not(:disabled) {
            transform: translateY(0);
        }

        button:disabled {
            background: #ccc;
            cursor: not-allowed;
            opacity: 0.6;
        }

        .button-group {
            display: flex;
            gap: 10px;
            margin-top: 20px;
        }

        .button-group button {
            flex: 1;
        }

        .response-section {
            margin-top: 30px;
            display: none;
        }

        .response-section.show {
            display: block;
        }

        .response-header {
            background: #f5f7ff;
            padding: 12px 16px;
            border-radius: 8px 8px 0 0;
            font-weight: 600;
            color: #667eea;
            border: 2px solid #667eea;
            border-bottom: none;
        }

        .response-content {
            background: #f9fafb;
            padding: 16px;
            border: 2px solid #667eea;
            border-top: none;
            border-radius: 0 0 8px 8px;
        }

        #searchResponseSection .response-content {
            max-height: 500px;
            overflow: auto;
        }

        pre {
            margin: 0;
            white-space: pre-wrap;
            word-wrap: break-word;
            font-size: 13px;
            line-height: 1.6;
            color: #333;
        }

        .loading {
            text-align: center;
            padding: 20px;
            color: #667eea;
            font-weight: 600;
        }

        .error {
            background: #fee;
            color: #c33;
            padding: 12px 16px;
            border-radius: 8px;
            margin-top: 10px;
            border: 1px solid #fcc;
        }

        .success {
            background: #efe;
            color: #3c3;
            padding: 12px 16px;
            border-radius: 8px;
            margin-top: 10px;
            border: 1px solid #cfc;
        }

        .mode-indicator {
            display: inline-block;
            padding: 4px 12px;
            border-radius: 20px;
            font-size: 12px;
            font-weight: 600;
            margin-left: 10px;
        }

        .mode-indicator.live {
            background: #d4edda;
            color: #155724;
        }

        .mode-indicator.manual {
            background: #fff3cd;
            color: #856404;
        }

        .hidden {
            display: none;
        }

        @keyframes spin {
            to { transform: rotate(360deg); }
        }

        .spinner {
            border: 3px solid #f3f3f3;
            border-top: 3px solid #667eea;
            border-radius: 50%;
            width: 40px;
            height: 40px;
            animation: spin 1s linear infinite;
            margin: 20px auto;
        }
    </style>
</head>
<body>
    <div class="container">
        <h1>Experian Address Search</h1>

        <div class="form-group">
            <label for="apiKey">API Key / Auth Token:</label>
            <input type="password" id="apiKey" placeholder="Enter your API key">
        </div>

        <div class="checkbox-group">
            <input type="checkbox" id="liveMode" checked>
            <label for="liveMode">
                Live Mode (Auto-search as you type)
                <span class="mode-indicator live" id="modeIndicator">LIVE MODE</span>
            </label>
        </div>

        <!-- Advanced Options -->
        <details style="margin-bottom: 20px;">
            <summary style="cursor: pointer; font-weight: 600; color: #667eea; padding: 10px 0;">Advanced Search Options</summary>

            <div style="background: #f5f7ff; padding: 20px; border-radius: 8px; margin-top: 10px;">
                <div class="options-grid">
                    <div class="form-group">
                        <label for="country">Country:</label>
                        <input type="text" id="country" value="AUS" placeholder="e.g., AUS, USA, GBR">
                    </div>

                    <div class="form-group">
                        <label for="layout">Layout:</label>
                        <input type="text" id="layout" value="CivicaAUS" placeholder="e.g., CivicaAUS">
                    </div>

                    <div class="form-group">
                        <label for="engineType">Engine Type:</label>
                        <select id="engineType">
                            <option value="SingleLine" selected>SingleLine</option>
                            <option value="Singleline">Singleline</option>
                            <option value="Intuitive">Intuitive</option>
                            <option value="Verification">Verification</option>
                            <option value="Keyfinder">Keyfinder</option>
                        </select>
                    </div>

                    <div class="form-group">
                        <label for="intensity">Search Intensity:</label>
                        <select id="intensity">
                            <option value="Exact">Exact - Strictest matching</option>
                            <option value="Close">Close - Moderate matching</option>
                            <option value="Extensive" selected>Extensive - Widest matching</option>
                        </select>
                        <div class="info-text">Controls how strict the address matching is</div>
                    </div>

                    <div class="form-group">
                        <label for="promptSet">Prompt Set:</label>
                        <select id="promptSet">
                            <option value="OneLine">OneLine</option>
                            <option value="Default" selected>Default</option>
                            <option value="Generic">Generic</option>
                            <option value="Optimal">Optimal</option>
                            <option value="Alternate">Alternate</option>
                            <option value="Alternate2">Alternate2</option>
                            <option value="Alternate3">Alternate3</option>
                        </select>
                        <div class="info-text">Determines the address display format</div>
                    </div>

                    <div class="form-group">
                        <label for="threshold">Threshold (1-100):</label>
                        <input type="number" id="threshold" value="10" min="1" max="100">
                        <div class="info-text">Max results to return</div>
                    </div>

                    <div class="form-group">
                        <label for="timeout">Timeout (ms):</label>
                        <input type="number" id="timeout" value="1000" min="0" step="100">
                        <div class="info-text">Max wait time for response</div>
                    </div>

                    <div class="checkbox-group" style="margin-bottom: 0;">
                        <input type="checkbox" id="flatten" checked>
                        <label for="flatten">Flatten Results</label>
                    </div>

                    <div class="checkbox-group" style="margin-bottom: 0;">
                        <input type="checkbox" id="formattedAddress" checked>
                        <label for="formattedAddress">Formatted Address in Picklist</label>
                    </div>
                </div>

                <button type="button" id="resetOptionsBtn" class="full-width" style="margin-top: 20px; background: linear-gradient(135deg, #6c757d 0%, #495057 100%);">
                    Reset to Defaults
                </button>

                <div id="currentSettings" class="full-width" style="margin-top: 15px; padding: 10px; background: #fff; border-radius: 6px; font-size: 12px; color: #666;">
                    <strong>Current Settings:</strong>
                    <div id="settingsSummary" style="margin-top: 5px; font-family: monospace;"></div>
                </div>
            </div>
        </details>

        <div class="form-group autocomplete-container">
            <label for="searchAddress">Search Address:</label>
            <input type="text" id="searchAddress" placeholder="Start typing an address...">
            <div class="autocomplete-dropdown" id="autocompleteDropdown"></div>
        </div>

        <!-- Live Mode Section -->
        <div id="liveModeSection">
            <button id="getAddressBtn" disabled>Get Full Address Details</button>

            <div class="response-section" id="liveAddressResponseSection">
                <div class="response-header">Full Address Details</div>
                <div class="response-content">
                    <pre id="liveAddressResponse"></pre>
                </div>
            </div>
        </div>

        <!-- Manual Mode Section -->
        <div id="manualModeSection" class="hidden">
            <div class="button-group">
                <button id="manualSearchBtn">Search Address</button>
            </div>

            <div class="response-section" id="searchResponseSection">
                <div class="response-header">Search Response (Step 1)</div>
                <div class="response-content">
                    <div id="searchResponse"></div>
                </div>
            </div>

            <div class="response-section" id="addressResponseSection">
                <div class="response-header">Address Response (Step 2)</div>
                <div class="response-content">
                    <div id="addressResponse"></div>
                </div>
            </div>
        </div>

        <div id="messages"></div>
    </div>

    <script>
        const apiKeyInput = document.getElementById('apiKey');
        const searchAddressInput = document.getElementById('searchAddress');
        const autocompleteDropdown = document.getElementById('autocompleteDropdown');
        const getAddressBtn = document.getElementById('getAddressBtn');
        const liveModeCheckbox = document.getElementById('liveMode');
        const modeIndicator = document.getElementById('modeIndicator');
        const liveModeSection = document.getElementById('liveModeSection');
        const manualModeSection = document.getElementById('manualModeSection');
        const manualSearchBtn = document.getElementById('manualSearchBtn');
        const searchResponseSection = document.getElementById('searchResponseSection');
        const addressResponseSection = document.getElementById('addressResponseSection');
        const searchResponse = document.getElementById('searchResponse');
        const addressResponse = document.getElementById('addressResponse');
        const liveAddressResponseSection = document.getElementById('liveAddressResponseSection');
        const liveAddressResponse = document.getElementById('liveAddressResponse');
        const messages = document.getElementById('messages');

        // Advanced options
        const countryInput = document.getElementById('country');
        const layoutInput = document.getElementById('layout');
        const intensitySelect = document.getElementById('intensity');
        const promptSetSelect = document.getElementById('promptSet');
        const thresholdInput = document.getElementById('threshold');
        const timeoutInput = document.getElementById('timeout');
        const flattenCheckbox = document.getElementById('flatten');
        const formattedAddressCheckbox = document.getElementById('formattedAddress');
        const engineTypeSelect = document.getElementById('engineType');

        const API_ENDPOINT = 'https://ws3.ondemand.qas.com/ProOnDemand/V3/ProOnDemandService.asmx';

        let searchResults = [];
        let selectedResult = null;
        let debounceTimer = null;

        // Default values
        const defaults = {
            country: 'AUS',
            layout: 'CivicaAUS',
            intensity: 'Extensive',
            promptSet: 'Default',
            threshold: '10',
            timeout: '1000',
            flatten: true,
            formattedAddress: true,
            engineType: 'SingleLine'
        };

        // Reset to defaults function
        function resetToDefaults() {
            countryInput.value = defaults.country;
            layoutInput.value = defaults.layout;
            intensitySelect.value = defaults.intensity;
            promptSetSelect.value = defaults.promptSet;
            thresholdInput.value = defaults.threshold;
            timeoutInput.value = defaults.timeout;
            flattenCheckbox.checked = defaults.flatten;
            formattedAddressCheckbox.checked = defaults.formattedAddress;
            engineTypeSelect.value = defaults.engineType;
            updateSettingsSummary();
            showMessage('Settings reset to defaults', 'success');
        }

        // Update settings summary
        function updateSettingsSummary() {
            const summary = document.getElementById('settingsSummary');
            summary.innerHTML = `
                Country: <strong>${countryInput.value || 'AUS'}</strong> |
                Engine: <strong>${engineTypeSelect.value}</strong> |
                Intensity: <strong>${intensitySelect.value}</strong><br>
                PromptSet: <strong>${promptSetSelect.value}</strong> |
                Threshold: <strong>${thresholdInput.value}</strong> |
                Timeout: <strong>${timeoutInput.value}ms</strong><br>
                Flatten: <strong>${flattenCheckbox.checked ? 'Yes' : 'No'}</strong> |
                Formatted: <strong>${formattedAddressCheckbox.checked ? 'Yes' : 'No'}</strong>
            `;
        }

        // Initialize settings summary
        updateSettingsSummary();

        // Add event listeners for settings changes
        [countryInput, layoutInput, intensitySelect, promptSetSelect, thresholdInput,
         timeoutInput, flattenCheckbox, formattedAddressCheckbox, engineTypeSelect].forEach(element => {
            element.addEventListener('change', updateSettingsSummary);
            element.addEventListener('input', updateSettingsSummary);
        });

        // Reset button
        document.getElementById('resetOptionsBtn').addEventListener('click', resetToDefaults);

        // Toggle between live and manual mode
        liveModeCheckbox.addEventListener('change', function() {
            const isLive = this.checked;
            if (isLive) {
                modeIndicator.textContent = 'LIVE MODE';
                modeIndicator.className = 'mode-indicator live';
                liveModeSection.classList.remove('hidden');
                manualModeSection.classList.add('hidden');
                autocompleteDropdown.classList.remove('show');
            } else {
                modeIndicator.textContent = 'MANUAL MODE';
                modeIndicator.className = 'mode-indicator manual';
                liveModeSection.classList.add('hidden');
                manualModeSection.classList.remove('hidden');
                autocompleteDropdown.classList.remove('show');
            }
            selectedResult = null;
            getAddressBtn.disabled = true;
        });

        // Live mode: Search as user types
        searchAddressInput.addEventListener('input', function() {
            const query = this.value.trim();

            if (!liveModeCheckbox.checked) {
                return; // Don't auto-search in manual mode
            }

            clearTimeout(debounceTimer);

            if (query.length < 4) {
                autocompleteDropdown.classList.remove('show');
                selectedResult = null;
                getAddressBtn.disabled = true;
                return;
            }

            debounceTimer = setTimeout(() => {
                performSearch(query);
            }, 300);
        });

        // Manual mode: Search button
        manualSearchBtn.addEventListener('click', function() {
            const query = searchAddressInput.value.trim();
            if (!query) {
                showMessage('Please enter a search address', 'error');
                return;
            }
            performSearch(query, true);
        });

        // Perform SOAP search (Step 1)
        async function performSearch(query, isManual = false) {
            const apiKey = apiKeyInput.value.trim();
            if (!apiKey) {
                showMessage('Please enter an API key', 'error');
                return;
            }

            if (isManual) {
                searchResponse.textContent = 'Loading...';
                searchResponseSection.classList.add('show');
            }

            // Get configuration values
            const country = countryInput.value.trim() || 'AUS';
            const layout = layoutInput.value.trim() || 'CivicaAUS';
            const intensity = intensitySelect.value || 'Extensive';
            const promptSet = promptSetSelect.value || 'Default';
            const threshold = thresholdInput.value || '10';
            const timeout = timeoutInput.value || '1000';
            const flatten = flattenCheckbox.checked ? 'true' : 'false';
            const formattedAddress = formattedAddressCheckbox.checked ? 'true' : 'false';
            const engineType = engineTypeSelect.value || 'SingleLine';

            const soapRequest = `<?xml version="1.0" encoding="utf-8"?>
<soap:Envelope xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema" xmlns:soap="http://schemas.xmlsoap.org/soap/envelope/">
<soap:Header>
<QAQueryHeader xmlns="http://www.qas.com/OnDemand-2011-03">
<QAAuthentication>
<Username>string</Username>
<Password>string</Password>
</QAAuthentication>
<Security>xml</Security>
</QAQueryHeader>
</soap:Header>
<soap:Body>
<QASearch Localisation="string" RequestTag="string" xmlns="http://www.qas.com/OnDemand-2011-03">
<Country>${escapeXml(country)}</Country>
<Engine EngineType="${escapeXml(engineType)}" Flatten="${flatten}" Intensity="${escapeXml(intensity)}" PromptSet="${escapeXml(promptSet)}" Threshold="${escapeXml(threshold)}" Timeout="${escapeXml(timeout)}" />
<Layout>${escapeXml(layout)}</Layout>
<Search>${escapeXml(query)}</Search>
<FormattedAddressInPicklist>${formattedAddress}</FormattedAddressInPicklist>
</QASearch>
</soap:Body>
</soap:Envelope>`;

            try {
                const response = await fetch(API_ENDPOINT, {
                    method: 'POST',
                    headers: {
                        'Auth-Token': apiKey,
                        'Content-Type': 'text/xml',
                        'Accept': 'application/xml',
                        'SOAPAction': 'http://www.qas.com/OnDemand-2011-03/DoSearch'
                    },
                    body: soapRequest
                });

                if (!response.ok) {
                    throw new Error(`HTTP error! status: ${response.status}`);
                }

                const xmlText = await response.text();
                const data = parseXmlToJson(xmlText);

                if (isManual) {
                    const formattedSearch = formatSearchResponseBeautified(data);
                    searchResponse.innerHTML = formattedSearch;
                } else {
                    parseAndDisplayResults(data);
                }

            } catch (error) {
                console.error('Search error:', error);
                if (isManual) {
                    searchResponse.textContent = `Error: ${error.message}`;
                } else {
                    showMessage(`Search failed: ${error.message}`, 'error');
                    autocompleteDropdown.classList.remove('show');
                }
            }
        }

        // Parse JSON response and display in dropdown
        function parseAndDisplayResults(data) {
            searchResults = [];
            autocompleteDropdown.innerHTML = '';

            try {
                // Navigate through the XML-parsed structure
                const soapBody = data['soap:Envelope']?.['soap:Body'];
                if (!soapBody) {
                    throw new Error('Invalid SOAP response structure');
                }

                const searchResult = soapBody['QASearchResult'];
                const picklist = searchResult?.['QAPicklist'];

                if (!picklist) {
                    autocompleteDropdown.innerHTML = '<div class="autocomplete-item">No results found</div>';
                    autocompleteDropdown.classList.add('show');
                    return;
                }

                let picklistEntries = picklist['PicklistEntry'];

                if (!picklistEntries) {
                    autocompleteDropdown.innerHTML = '<div class="autocomplete-item">No results found</div>';
                    autocompleteDropdown.classList.add('show');
                    return;
                }

                // Ensure it's an array
                searchResults = Array.isArray(picklistEntries) ? picklistEntries : [picklistEntries];

                searchResults.forEach((entry, index) => {
                    const item = document.createElement('div');
                    item.className = 'autocomplete-item';
                    item.dataset.index = index;

                    // Extract text content from XML nodes
                    const mainAddress = getTextContent(entry['Picklist']) || getTextContent(entry['PartialAddress']) || 'Unknown Address';
                    const postcode = getTextContent(entry['Postcode']) || '';
                    const score = getTextContent(entry['Score']) || 'N/A';

                    item.innerHTML = `
                        <div class="address-main">${escapeHtml(mainAddress)}</div>
                        <div class="address-details">Postcode: ${escapeHtml(postcode)} | Score: ${score}</div>
                    `;

                    item.addEventListener('click', () => selectResult(index));
                    autocompleteDropdown.appendChild(item);
                });

                autocompleteDropdown.classList.add('show');

            } catch (error) {
                console.error('Parse error:', error);
                autocompleteDropdown.innerHTML = '<div class="autocomplete-item">Error parsing results: ' + error.message + '</div>';
                autocompleteDropdown.classList.add('show');
            }
        }

        // Helper function to extract text content from XML parsed nodes
        function getTextContent(node) {
            if (!node) return '';
            if (typeof node === 'string') return node;
            if (node['#text']) return node['#text'];
            // If the node has only text content
            for (let key in node) {
                if (key !== '@attributes' && typeof node[key] === 'string') {
                    return node[key];
                }
            }
            return '';
        }

        // Select a result from dropdown
        function selectResult(index) {
            selectedResult = searchResults[index];
            const displayAddress = getTextContent(selectedResult['Picklist']) || getTextContent(selectedResult['PartialAddress']);
            searchAddressInput.value = displayAddress;
            autocompleteDropdown.classList.remove('show');
            getAddressBtn.disabled = false;

            // Highlight selected
            document.querySelectorAll('.autocomplete-item').forEach((item, i) => {
                item.classList.toggle('selected', i === index);
            });
        }

        // Live mode: Get full address details
        getAddressBtn.addEventListener('click', function() {
            if (selectedResult) {
                const moniker = getTextContent(selectedResult['Moniker']);
                if (moniker) {
                    getAddressDetails(moniker);
                }
            }
        });

        // Get full address details (Step 2)
        async function getAddressDetails(moniker, isManual = false) {
            const apiKey = apiKeyInput.value.trim();
            if (!apiKey) {
                showMessage('Please enter an API key', 'error');
                return;
            }

            if (isManual) {
                addressResponse.textContent = 'Loading...';
                addressResponseSection.classList.add('show');
            } else {
                showMessage('Loading address details...', 'loading');
            }

            const soapRequest = `<?xml version="1.0" encoding="utf-8"?>
<soapenv:Envelope xmlns:soapenv="http://schemas.xmlsoap.org/soap/envelope/" xmlns:ond="http://www.qas.com/OnDemand-2011-03">
  <soapenv:Header>
    <ond:QAQueryHeader>
      <ond:Security>xml</ond:Security>
    </ond:QAQueryHeader>
  </soapenv:Header>
  <soapenv:Body>
    <ond:QAGetAddress Localisation="AUS" RequestTag="ExperianSearch">
      <ond:Layout>CivicaAUS</ond:Layout>
      <ond:Moniker>${escapeXml(moniker)}</ond:Moniker>
    </ond:QAGetAddress>
  </soapenv:Body>
</soapenv:Envelope>`;

            try {
                const response = await fetch(API_ENDPOINT, {
                    method: 'POST',
                    headers: {
                        'Auth-Token': apiKey,
                        'Content-Type': 'text/xml; charset=utf-8',
                        'Accept': 'application/xml',
                        'SOAPAction': 'http://www.qas.com/OnDemand-2011-03/DoGetAddress'
                    },
                    body: soapRequest
                });

                if (!response.ok) {
                    throw new Error(`HTTP error! status: ${response.status}`);
                }

                const xmlText = await response.text();
                const data = parseXmlToJson(xmlText);

                if (isManual) {
                    // Manual mode: Display beautified response like live mode
                    const formattedAddress = formatAddressResponseBeautifiedFull(data);
                    addressResponse.innerHTML = formattedAddress;
                } else {
                    // Live mode: Display beautified response
                    const formattedAddress = formatAddressResponseBeautified(data);
                    liveAddressResponse.innerHTML = formattedAddress;
                    liveAddressResponseSection.classList.add('show');
                    console.log('Full Address Details:', data);
                }

            } catch (error) {
                console.error('Get address error:', error);
                if (isManual) {
                    addressResponse.textContent = `Error: ${error.message}`;
                } else {
                    showMessage(`Failed to get address details: ${error.message}`, 'error');
                }
            }
        }

        // Format search response for beautified HTML display (Manual Mode - Step 1)
        function formatSearchResponseBeautified(data) {
            try {
                const soapBody = data['soap:Envelope']?.['soap:Body'];
                const searchResult = soapBody?.['QASearchResult'];
                const picklist = searchResult?.['QAPicklist'];

                if (!picklist) {
                    return '<div style="color: #888;">No search results available</div>';
                }

                let picklistEntries = picklist['PicklistEntry'];
                if (!picklistEntries) {
                    return '<div style="color: #888;">No addresses found</div>';
                }

                // Ensure it's an array
                if (!Array.isArray(picklistEntries)) {
                    picklistEntries = [picklistEntries];
                }

                // Get picklist metadata
                const fullPicklistMoniker = getTextContent(picklist['FullPicklistMoniker']) || '';
                const prompt = getTextContent(picklist['Prompt']) || '';
                const total = getTextContent(picklist['Total']) || picklistEntries.length;
                const autoFormatSafe = picklist['@attributes']?.AutoFormatSafe || '';

                let html = '<div style="font-family: -apple-system, BlinkMacSystemFont, \'Segoe UI\', Roboto, sans-serif;">';

                // Metadata section
                html += `<div style="margin-bottom: 25px; padding: 15px; background: #f5f7ff; border-radius: 8px; border-left: 4px solid #667eea;">`;
                html += `<div style="font-weight: 700; color: #667eea; font-size: 14px; margin-bottom: 8px;">SEARCH METADATA</div>`;
                html += `<div style="font-size: 13px; color: #666; margin-bottom: 4px;">Total Results: <strong>${escapeHtml(total.toString())}</strong></div>`;
                if (autoFormatSafe) html += `<div style="font-size: 13px; color: #666; margin-bottom: 4px;">Auto Format Safe: <strong>${escapeHtml(autoFormatSafe)}</strong></div>`;
                if (prompt) html += `<div style="font-size: 13px; color: #666; margin-bottom: 4px;">Prompt: <strong>${escapeHtml(prompt)}</strong></div>`;
                html += `</div>`;

                // Address results
                html += `<div style="margin-bottom: 25px;">`;
                html += `<div style="font-weight: 700; color: #667eea; font-size: 15px; margin-bottom: 12px; text-transform: uppercase; letter-spacing: 0.5px; border-bottom: 2px solid #667eea; padding-bottom: 5px;">SEARCH RESULTS</div>`;

                picklistEntries.forEach((entry, index) => {
                    const moniker = getTextContent(entry['Moniker']) || '';
                    const partialAddress = getTextContent(entry['PartialAddress']) || '';
                    const picklist = getTextContent(entry['Picklist']) || '';
                    const postcode = getTextContent(entry['Postcode']) || '';
                    const score = getTextContent(entry['Score']) || '';
                    const fullAddress = entry['@attributes']?.FullAddress || '';

                    html += `<div style="background: ${index % 2 === 0 ? '#ffffff' : '#f9fafb'}; padding: 15px; margin-bottom: 10px; border-radius: 6px; border: 1px solid #e0e0e0;">`;
                    html += `<div style="font-weight: 700; color: #333; font-size: 14px; margin-bottom: 10px; display: flex; align-items: center;">`;
                    html += `<span style="background: #667eea; color: white; padding: 4px 10px; border-radius: 4px; margin-right: 10px; font-size: 12px;">#${index + 1}</span>`;
                    html += `${escapeHtml(picklist || partialAddress)}`;
                    if (fullAddress === 'true') {
                        html += `<span style="background: #4caf50; color: white; padding: 2px 6px; border-radius: 3px; font-size: 10px; margin-left: 8px;">FULL ADDRESS</span>`;
                    }
                    html += `</div>`;

                    html += `<div style="display: grid; grid-template-columns: 1fr 1fr; gap: 8px; font-size: 13px;">`;

                    if (partialAddress && partialAddress !== picklist) {
                        html += `<div style="color: #666;">Partial Address:</div>`;
                        html += `<div style="color: #333; font-weight: 600;">${escapeHtml(partialAddress)}</div>`;
                    }

                    if (postcode) {
                        html += `<div style="color: #666;">Postcode:</div>`;
                        html += `<div style="color: #333; font-weight: 600;">${escapeHtml(postcode)}</div>`;
                    }

                    if (score) {
                        const scoreNum = parseInt(score);
                        let scoreColor = '#4caf50';
                        if (scoreNum < 70) scoreColor = '#f44336';
                        else if (scoreNum < 90) scoreColor = '#ff9800';

                        html += `<div style="color: #666;">Match Score:</div>`;
                        html += `<div style="color: ${scoreColor}; font-weight: 700;">${escapeHtml(score)}%</div>`;
                    }

                    html += `</div>`;

                    if (moniker) {
                        html += `<div style="margin-top: 10px; padding-top: 10px; border-top: 1px solid #e0e0e0;">`;
                        html += `<div style="display: flex; align-items: center; justify-content: space-between; margin-bottom: 4px;">`;
                        html += `<div style="color: #666; font-size: 11px;">Moniker:</div>`;
                        html += `<button onclick="applyMoniker('${escapeHtml(moniker).replace(/'/g, "\\'")}'); return false;" style="background: #4caf50; color: white; border: none; padding: 2px 6px; border-radius: 3px; font-size: 9px; cursor: pointer; font-weight: 600; transition: background 0.2s; min-width: 40px; width: auto;" onmouseover="this.style.background='#45a049'" onmouseout="this.style.background='#4caf50'">Apply</button>`;
                        html += `</div>`;
                        html += `<div style="color: #333; font-family: monospace; font-size: 11px; background: #f5f5f5; padding: 6px; border-radius: 4px; word-break: break-all;">${escapeHtml(moniker)}</div>`;
                        html += `</div>`;
                    }

                    html += `</div>`;
                });

                html += `</div>`;
                html += '</div>';

                return html;
            } catch (error) {
                console.error('Format search error:', error);
                return '<div style="color: #c33;">Error formatting search results</div>';
            }
        }

        // Format address response for beautified HTML display - FULL version (Manual Mode - shows ALL fields)
        function formatAddressResponseBeautifiedFull(data) {
            try {
                const soapBody = data['soap:Envelope']?.['soap:Body'];
                const address = soapBody?.['Address'];
                const qaAddress = address?.['QAAddress'];

                if (!qaAddress) {
                    return '<div style="color: #888;">No address details available</div>';
                }

                let addressLines = qaAddress['AddressLine'];
                if (!addressLines) {
                    return '<div style="color: #888;">No address lines found</div>';
                }

                // Ensure it's an array
                if (!Array.isArray(addressLines)) {
                    addressLines = [addressLines];
                }

                // Group address lines by category (including empty values)
                const categories = {
                    'Property Details': [],
                    'Street Details': [],
                    'Location Details': [],
                    'Postal Details': [],
                    'Additional Information': []
                };

                addressLines.forEach(line => {
                    const label = getTextContent(line['Label']);
                    const lineText = getTextContent(line['Line']);
                    const lineContent = line['@attributes']?.LineContent || '';

                    // Categorize based on label
                    if (label.includes('Flat') || label.includes('Unit') || label.includes('Building') || label.includes('Level') || label.includes('Allotment') || label.includes('Lot') || label.includes('Sub-building')) {
                        categories['Property Details'].push({ label, value: lineText || '<empty>', isEmpty: !lineText, lineContent });
                    } else if (label.includes('Street') || label.includes('Number')) {
                        categories['Street Details'].push({ label, value: lineText || '<empty>', isEmpty: !lineText, lineContent });
                    } else if (label.includes('Locality') || label.includes('State') || label.includes('City') || label.includes('Country')) {
                        categories['Location Details'].push({ label, value: lineText || '<empty>', isEmpty: !lineText, lineContent });
                    } else if (label.includes('Postcode') || label.includes('Barcode') || label.includes('postal') || label.includes('delivery')) {
                        categories['Postal Details'].push({ label, value: lineText || '<empty>', isEmpty: !lineText, lineContent });
                    } else {
                        categories['Additional Information'].push({ label, value: lineText || '<empty>', isEmpty: !lineText, lineContent });
                    }
                });

                let html = '<div style="font-family: -apple-system, BlinkMacSystemFont, \'Segoe UI\', Roboto, sans-serif;">';

                // Display each category
                Object.keys(categories).forEach(category => {
                    if (categories[category].length > 0) {
                        html += `<div style="margin-bottom: 25px;">`;
                        html += `<div style="font-weight: 700; color: #667eea; font-size: 15px; margin-bottom: 12px; text-transform: uppercase; letter-spacing: 0.5px; border-bottom: 2px solid #667eea; padding-bottom: 5px;">${category}</div>`;

                        categories[category].forEach(item => {
                            const emptyStyle = item.isEmpty ? 'color: #999; font-style: italic;' : 'color: #333; font-weight: 600;';
                            const lineContentBadge = item.lineContent && item.lineContent !== 'None' ?
                                `<span style="background: #e3f2fd; color: #1976d2; padding: 2px 6px; border-radius: 3px; font-size: 10px; margin-left: 8px;">${item.lineContent}</span>` : '';

                            html += `<div style="display: flex; padding: 10px 0; border-bottom: 1px solid #f0f0f0; align-items: center;">`;
                            html += `<div style="flex: 0 0 240px; color: #666; font-size: 13px;">${escapeHtml(item.label)}:${lineContentBadge}</div>`;
                            html += `<div style="flex: 1; ${emptyStyle} font-size: 14px;">${escapeHtml(item.value)}</div>`;
                            html += `</div>`;
                        });

                        html += `</div>`;
                    }
                });

                // Add metadata if available
                const dpvStatus = qaAddress['@attributes']?.DPVStatus;
                const overflow = qaAddress['@attributes']?.Overflow;
                const truncated = qaAddress['@attributes']?.Truncated;

                if (dpvStatus || overflow || truncated) {
                    html += `<div style="margin-top: 20px; padding: 15px; background: #f5f7ff; border-radius: 8px; border-left: 4px solid #667eea;">`;
                    html += `<div style="font-weight: 700; color: #667eea; font-size: 14px; margin-bottom: 8px;">METADATA</div>`;
                    if (dpvStatus) html += `<div style="font-size: 13px; color: #666; margin-bottom: 4px;">DPV Status: <strong>${escapeHtml(dpvStatus)}</strong></div>`;
                    if (overflow) html += `<div style="font-size: 13px; color: #666; margin-bottom: 4px;">Overflow: <strong>${overflow}</strong></div>`;
                    if (truncated) html += `<div style="font-size: 13px; color: #666;">Truncated: <strong>${truncated}</strong></div>`;
                    html += `</div>`;
                }

                html += '</div>';

                return html || '<div style="color: #888;">No address information to display</div>';
            } catch (error) {
                console.error('Format error:', error);
                return '<div style="color: #c33;">Error formatting address details</div>';
            }
        }

        // Format address response for beautified HTML display (Live Mode)
        function formatAddressResponseBeautified(data) {
            try {
                const soapBody = data['soap:Envelope']?.['soap:Body'];
                const address = soapBody?.['Address'];
                const qaAddress = address?.['QAAddress'];

                if (!qaAddress) {
                    return '<div style="color: #888;">No address details available</div>';
                }

                let addressLines = qaAddress['AddressLine'];
                if (!addressLines) {
                    return '<div style="color: #888;">No address lines found</div>';
                }

                // Ensure it's an array
                if (!Array.isArray(addressLines)) {
                    addressLines = [addressLines];
                }

                // Group address lines by category
                const categories = {
                    'Property': [],
                    'Street': [],
                    'Location': [],
                    'Postal': [],
                    'Other': []
                };

                addressLines.forEach(line => {
                    const label = getTextContent(line['Label']);
                    const lineText = getTextContent(line['Line']);

                    if (lineText) {
                        // Categorize based on label
                        if (label.includes('Flat') || label.includes('Unit') || label.includes('Building') || label.includes('Level') || label.includes('Allotment') || label.includes('Lot')) {
                            categories['Property'].push({ label, value: lineText });
                        } else if (label.includes('Street') || label.includes('Number')) {
                            categories['Street'].push({ label, value: lineText });
                        } else if (label.includes('Locality') || label.includes('State') || label.includes('City')) {
                            categories['Location'].push({ label, value: lineText });
                        } else if (label.includes('Postcode') || label.includes('Barcode') || label.includes('postal')) {
                            categories['Postal'].push({ label, value: lineText });
                        } else {
                            categories['Other'].push({ label, value: lineText });
                        }
                    }
                });

                let html = '<div style="font-family: -apple-system, BlinkMacSystemFont, \'Segoe UI\', Roboto, sans-serif;">';

                // Display each category
                Object.keys(categories).forEach(category => {
                    if (categories[category].length > 0) {
                        html += `<div style="margin-bottom: 20px;">`;
                        html += `<div style="font-weight: 700; color: #667eea; font-size: 14px; margin-bottom: 10px; text-transform: uppercase; letter-spacing: 0.5px;">${category}</div>`;

                        categories[category].forEach(item => {
                            html += `<div style="display: flex; padding: 8px 0; border-bottom: 1px solid #f0f0f0;">`;
                            html += `<div style="flex: 0 0 200px; color: #666; font-size: 13px;">${escapeHtml(item.label)}:</div>`;
                            html += `<div style="flex: 1; color: #333; font-weight: 600; font-size: 14px;">${escapeHtml(item.value)}</div>`;
                            html += `</div>`;
                        });

                        html += `</div>`;
                    }
                });

                html += '</div>';

                return html || '<div style="color: #888;">No address information to display</div>';
            } catch (error) {
                console.error('Format error:', error);
                return '<div style="color: #c33;">Error formatting address details</div>';
            }
        }

        // Format address response for display (kept for compatibility)
        function formatAddressResponse(data) {
            try {
                const soapBody = data['soap:Envelope']?.['soap:Body'];
                const address = soapBody?.['Address'];
                const qaAddress = address?.['QAAddress'];

                if (!qaAddress) {
                    return 'Address details retrieved (see console for full data)';
                }

                let addressLines = qaAddress['AddressLine'];
                if (!addressLines) {
                    return 'Address details retrieved (see console for full data)';
                }

                // Ensure it's an array
                if (!Array.isArray(addressLines)) {
                    addressLines = [addressLines];
                }

                let formatted = 'Address Details:\n\n';

                addressLines.forEach(line => {
                    const label = getTextContent(line['Label']);
                    const lineText = getTextContent(line['Line']);

                    if (lineText) {
                        formatted += `${label}: ${lineText}\n`;
                    }
                });

                return formatted || 'Address details retrieved (see console for full data)';
            } catch (error) {
                console.error('Format error:', error);
                return 'Address details retrieved (see console for full data)';
            }
        }

        // Apply moniker and get address details
        function applyMoniker(moniker) {
            if (!moniker) {
                showMessage('Invalid moniker', 'error');
                return;
            }

            // Show loading state
            addressResponse.innerHTML = '<div style="text-align: center; padding: 20px; color: #667eea;">Loading address details...</div>';
            addressResponseSection.classList.add('show');

            // Scroll to the response section
            addressResponseSection.scrollIntoView({ behavior: 'smooth', block: 'start' });

            // Make the second SOAP call
            getAddressDetails(moniker, true);
        }

        // Show messages
        function showMessage(text, type = 'info') {
            messages.innerHTML = `<div class="${type}">${escapeHtml(text)}</div>`;
            if (type !== 'loading') {
                setTimeout(() => {
                    messages.innerHTML = '';
                }, 5000);
            }
        }

        // XML to JSON parser
        function parseXmlToJson(xmlString) {
            const parser = new DOMParser();
            const xmlDoc = parser.parseFromString(xmlString, 'text/xml');

            // Check for parse errors
            const parserError = xmlDoc.querySelector('parsererror');
            if (parserError) {
                throw new Error('XML parsing error: ' + parserError.textContent);
            }

            function xmlToJson(xml) {
                let obj = {};

                if (xml.nodeType === 1) { // Element node
                    // Handle attributes
                    if (xml.attributes.length > 0) {
                        obj['@attributes'] = {};
                        for (let j = 0; j < xml.attributes.length; j++) {
                            const attribute = xml.attributes.item(j);
                            obj['@attributes'][attribute.nodeName] = attribute.nodeValue;
                        }
                    }
                } else if (xml.nodeType === 3) { // Text node
                    obj = xml.nodeValue.trim();
                }

                // Handle child nodes
                if (xml.hasChildNodes()) {
                    for (let i = 0; i < xml.childNodes.length; i++) {
                        const item = xml.childNodes.item(i);
                        const nodeName = item.nodeName;

                        if (typeof obj[nodeName] === 'undefined') {
                            const converted = xmlToJson(item);
                            if (converted !== '') {
                                obj[nodeName] = converted;
                            }
                        } else {
                            if (typeof obj[nodeName].push === 'undefined') {
                                const old = obj[nodeName];
                                obj[nodeName] = [];
                                obj[nodeName].push(old);
                            }
                            const converted = xmlToJson(item);
                            if (converted !== '') {
                                obj[nodeName].push(converted);
                            }
                        }
                    }
                }

                return obj;
            }

            return xmlToJson(xmlDoc);
        }

        // Utility functions
        function escapeXml(unsafe) {
            return unsafe.replace(/[<>&'"]/g, (c) => {
                switch (c) {
                    case '<': return '&lt;';
                    case '>': return '&gt;';
                    case '&': return '&amp;';
                    case '\'': return '&apos;';
                    case '"': return '&quot;';
                }
            });
        }

        function escapeHtml(unsafe) {
            return unsafe
                .replace(/&/g, "&amp;")
                .replace(/</g, "&lt;")
                .replace(/>/g, "&gt;")
                .replace(/"/g, "&quot;")
                .replace(/'/g, "&#039;");
        }

        // Close dropdown when clicking outside
        document.addEventListener('click', function(e) {
            if (!e.target.closest('.autocomplete-container')) {
                autocompleteDropdown.classList.remove('show');
            }
        });

        // Keyboard navigation for dropdown
        let currentFocus = -1;
        searchAddressInput.addEventListener('keydown', function(e) {
            const items = autocompleteDropdown.getElementsByClassName('autocomplete-item');
            if (e.key === 'ArrowDown') {
                currentFocus++;
                addActive(items);
                e.preventDefault();
            } else if (e.key === 'ArrowUp') {
                currentFocus--;
                addActive(items);
                e.preventDefault();
            } else if (e.key === 'Enter') {
                e.preventDefault();
                if (currentFocus > -1 && items[currentFocus]) {
                    items[currentFocus].click();
                }
            }
        });

        function addActive(items) {
            if (!items || items.length === 0) return false;
            removeActive(items);
            if (currentFocus >= items.length) currentFocus = 0;
            if (currentFocus < 0) currentFocus = items.length - 1;
            items[currentFocus].classList.add('selected');
            items[currentFocus].scrollIntoView({ block: 'nearest' });
        }

        function removeActive(items) {
            for (let i = 0; i < items.length; i++) {
                items[i].classList.remove('selected');
            }
        }
    </script>
</body>
</html>
